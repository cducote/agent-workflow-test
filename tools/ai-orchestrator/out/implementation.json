{
  "files": [
    {
      "path": "frontend/lib/math.ts",
      "content": "/**\n * Math functions wrapper for frontend\n * These functions wrap the backend math.js functions\n */\n\n// Import math functions from backend\n// In a real setup, these would be imported from the backend package\n// For now, we'll replicate the logic to maintain type safety\n\nexport function add(a: number, b: number): number {\n  if (a == null || b == null) {\n    return 0;\n  }\n  return a + b;\n}\n\nexport function subtract(a: number, b: number): number {\n  if (a == null || b == null) {\n    return 0;\n  }\n  return a - b;\n}\n\nexport function multiply(a: number, b: number): number {\n  if (a == null || b == null) {\n    return 0;\n  }\n  return a * b;\n}\n\nexport function divide(a: number, b: number): number {\n  if (a == null || b == null) {\n    return 0;\n  }\n  if (b === 0) {\n    throw new Error(\"Division by zero\");\n  }\n  return a / b;\n}\n\nexport function modulo(a: number, b: number): number {\n  if (a == null || b == null) {\n    return 0;\n  }\n  if (b === 0) {\n    throw new Error(\"Modulo by zero\");\n  }\n  return a % b;\n}\n\nexport function square(x: number): number | null {\n  if (x == null) {\n    return null;\n  }\n  return x * x;\n}\n\nexport function cube(x: number): number | null {\n  if (x == null) {\n    return null;\n  }\n  return x * x * x;\n}\n"
    },
    {
      "path": "frontend/store/calculatorStore.ts",
      "content": "import { create } from \"zustand\";\nimport { add, subtract, multiply, divide, modulo, square, cube } from \"@/lib/math\";\n\nexport type Operation = \"+\" | \"-\" | \"×\" | \"÷\" | \"%\" | \"x²\" | \"x³\" | null;\n\nexport interface HistoryItem {\n  id: string;\n  expression: string;\n  result: number;\n  timestamp: number;\n}\n\ninterface CalculatorState {\n  display: string;\n  currentValue: number;\n  previousValue: number | null;\n  operation: Operation;\n  history: HistoryItem[];\n  error: string | null;\n  shouldResetDisplay: boolean;\n\n  // Actions\n  inputDigit: (digit: string) => void;\n  inputDecimal: () => void;\n  setOperation: (op: Operation) => void;\n  calculate: () => void;\n  clear: () => void;\n  clearError: () => void;\n  addToHistory: (expression: string, result: number) => void;\n}\n\nexport const useCalculatorStore = create<CalculatorState>((set, get) => ({\n  display: \"0\",\n  currentValue: 0,\n  previousValue: null,\n  operation: null,\n  history: [],\n  error: null,\n  shouldResetDisplay: false,\n\n  inputDigit: (digit: string) => {\n    const state = get();\n    if (state.shouldResetDisplay) {\n      set({\n        display: digit,\n        currentValue: parseFloat(digit),\n        shouldResetDisplay: false,\n        error: null,\n      });\n    } else {\n      const newDisplay = state.display === \"0\" ? digit : state.display + digit;\n      set({\n        display: newDisplay,\n        currentValue: parseFloat(newDisplay),\n        error: null,\n      });\n    }\n  },\n\n  inputDecimal: () => {\n    const state = get();\n    if (state.shouldResetDisplay) {\n      set({\n        display: \"0.\",\n        currentValue: 0,\n        shouldResetDisplay: false,\n        error: null,\n      });\n    } else if (!state.display.includes(\".\")) {\n      const newDisplay = state.display + \".\";\n      set({\n        display: newDisplay,\n        error: null,\n      });\n    }\n  },\n\n  setOperation: (op: Operation) => {\n    const state = get();\n\n    // Handle unary operations (square, cube)\n    if (op === \"x²\" || op === \"x³\") {\n      try {\n        const result = op === \"x²\"\n          ? square(state.currentValue)\n          : cube(state.currentValue);\n\n        if (result === null) {\n          set({ error: \"Invalid operation\" });\n          return;\n        }\n\n        const expression = `${state.currentValue}${op}`;\n        get().addToHistory(expression, result);\n\n        set({\n          display: result.toString(),\n          currentValue: result,\n          previousValue: null,\n          operation: null,\n          shouldResetDisplay: true,\n          error: null,\n        });\n      } catch (error) {\n        set({ error: \"Error\" });\n      }\n      return;\n    }\n\n    // Handle binary operations\n    if (state.operation && state.previousValue !== null && !state.shouldResetDisplay) {\n      get().calculate();\n    }\n\n    set({\n      previousValue: state.currentValue,\n      operation: op,\n      shouldResetDisplay: true,\n      error: null,\n    });\n  },\n\n  calculate: () => {\n    const state = get();\n    if (state.operation === null || state.previousValue === null) {\n      return;\n    }\n\n    try {\n      let result: number;\n      const prev = state.previousValue;\n      const curr = state.currentValue;\n\n      switch (state.operation) {\n        case \"+\":\n          result = add(prev, curr);\n          break;\n        case \"-\":\n          result = subtract(prev, curr);\n          break;\n        case \"×\":\n          result = multiply(prev, curr);\n          break;\n        case \"÷\":\n          if (curr === 0) {\n            set({ error: \"Cannot divide by zero\" });\n            return;\n          }\n          result = divide(prev, curr);\n          break;\n        case \"%\":\n          if (curr === 0) {\n            set({ error: \"Cannot modulo by zero\" });\n            return;\n          }\n          result = modulo(prev, curr);\n          break;\n        default:\n          return;\n      }\n\n      const expression = `${prev} ${state.operation} ${curr}`;\n      get().addToHistory(expression, result);\n\n      set({\n        display: result.toString(),\n        currentValue: result,\n        previousValue: null,\n        operation: null,\n        shouldResetDisplay: true,\n        error: null,\n      });\n    } catch (error) {\n      set({ error: \"Error\" });\n    }\n  },\n\n  clear: () => {\n    set({\n      display: \"0\",\n      currentValue: 0,\n      previousValue: null,\n      operation: null,\n      history: [],\n      error: null,\n      shouldResetDisplay: false,\n    });\n  },\n\n  clearError: () => {\n    set({ error: null });\n  },\n\n  addToHistory: (expression: string, result: number) => {\n    const state = get();\n    const newItem: HistoryItem = {\n      id: Date.now().toString(),\n      expression,\n      result,\n      timestamp: Date.now(),\n    };\n\n    const newHistory = [newItem, ...state.history].slice(0, 10);\n    set({ history: newHistory });\n  },\n}));\n"
    },
    {
      "path": "frontend/components/OperationButtons.tsx",
      "content": "\"use client\";\n\nimport { useCalculatorStore, type Operation } from \"@/store/calculatorStore\";\nimport Button from \"./Button\";\n\nexport default function OperationButtons() {\n  const { setOperation } = useCalculatorStore();\n\n  const operations: { label: string; op: Operation }[] = [\n    { label: \"÷\", op: \"÷\" },\n    { label: \"×\", op: \"×\" },\n    { label: \"-\", op: \"-\" },\n    { label: \"+\", op: \"+\" },\n    { label: \"%\", op: \"%\" },\n    { label: \"x²\", op: \"x²\" },\n    { label: \"x³\", op: \"x³\" },\n  ];\n\n  return (\n    <div className=\"flex flex-col gap-3\">\n      {operations.map(({ label, op }) => (\n        <Button\n          key={label}\n          onClick={() => setOperation(op)}\n          variant=\"operation\"\n        >\n          {label}\n        </Button>\n      ))}\n    </div>\n  );\n}\n"
    },
    {
      "path": "frontend/__tests__/math.test.ts",
      "content": "import { add, subtract, multiply, divide, modulo, square, cube } from \"@/lib/math\";\n\ndescribe(\"Math functions\", () => {\n  describe(\"add\", () => {\n    it(\"should add two positive numbers\", () => {\n      expect(add(2, 3)).toBe(5);\n    });\n\n    it(\"should add negative numbers\", () => {\n      expect(add(-2, -3)).toBe(-5);\n    });\n\n    it(\"should handle null values\", () => {\n      expect(add(null as any, 3)).toBe(0);\n      expect(add(2, null as any)).toBe(0);\n    });\n  });\n\n  describe(\"subtract\", () => {\n    it(\"should subtract two numbers\", () => {\n      expect(subtract(5, 3)).toBe(2);\n    });\n\n    it(\"should handle negative results\", () => {\n      expect(subtract(3, 5)).toBe(-2);\n    });\n\n    it(\"should handle null values\", () => {\n      expect(subtract(null as any, 3)).toBe(0);\n      expect(subtract(5, null as any)).toBe(0);\n    });\n  });\n\n  describe(\"multiply\", () => {\n    it(\"should multiply two numbers\", () => {\n      expect(multiply(4, 3)).toBe(12);\n    });\n\n    it(\"should handle zero\", () => {\n      expect(multiply(5, 0)).toBe(0);\n    });\n\n    it(\"should handle negative numbers\", () => {\n      expect(multiply(-3, 4)).toBe(-12);\n    });\n\n    it(\"should handle null values\", () => {\n      expect(multiply(null as any, 3)).toBe(0);\n      expect(multiply(5, null as any)).toBe(0);\n    });\n  });\n\n  describe(\"divide\", () => {\n    it(\"should divide two numbers\", () => {\n      expect(divide(6, 3)).toBe(2);\n    });\n\n    it(\"should handle decimal results\", () => {\n      expect(divide(5, 2)).toBe(2.5);\n    });\n\n    it(\"should throw error on division by zero\", () => {\n      expect(() => divide(5, 0)).toThrow(\"Division by zero\");\n    });\n\n    it(\"should handle null values\", () => {\n      expect(divide(null as any, 3)).toBe(0);\n      expect(divide(5, null as any)).toBe(0);\n    });\n  });\n\n  describe(\"modulo\", () => {\n    it(\"should calculate modulo of two positive numbers\", () => {\n      expect(modulo(10, 3)).toBe(1);\n    });\n\n    it(\"should calculate modulo with zero result\", () => {\n      expect(modulo(6, 3)).toBe(0);\n    });\n\n    it(\"should handle negative dividend\", () => {\n      expect(modulo(-7, 3)).toBe(-1);\n    });\n\n    it(\"should handle negative divisor\", () => {\n      expect(modulo(7, -3)).toBe(1);\n    });\n\n    it(\"should handle both negative numbers\", () => {\n      expect(modulo(-7, -3)).toBe(-1);\n    });\n\n    it(\"should handle floating point numbers\", () => {\n      expect(modulo(5.5, 2)).toBeCloseTo(1.5);\n    });\n\n    it(\"should throw error on modulo by zero\", () => {\n      expect(() => modulo(5, 0)).toThrow(\"Modulo by zero\");\n    });\n\n    it(\"should handle null values\", () => {\n      expect(modulo(null as any, 3)).toBe(0);\n      expect(modulo(5, null as any)).toBe(0);\n    });\n\n    it(\"should handle edge case where dividend is smaller than divisor\", () => {\n      expect(modulo(2, 5)).toBe(2);\n    });\n  });\n\n  describe(\"square\", () => {\n    it(\"should square a positive number\", () => {\n      expect(square(5)).toBe(25);\n    });\n\n    it(\"should square a negative number\", () => {\n      expect(square(-3)).toBe(9);\n    });\n\n    it(\"should handle zero\", () => {\n      expect(square(0)).toBe(0);\n    });\n\n    it(\"should handle null values\", () => {\n      expect(square(null as any)).toBeNull();\n    });\n  });\n\n  describe(\"cube\", () => {\n    it(\"should cube a positive number\", () => {\n      expect(cube(3)).toBe(27);\n    });\n\n    it(\"should cube a negative number\", () => {\n      expect(cube(-2)).toBe(-8);\n    });\n\n    it(\"should handle zero\", () => {\n      expect(cube(0)).toBe(0);\n    });\n\n    it(\"should handle null values\", () => {\n      expect(cube(null as any)).toBeNull();\n    });\n  });\n});\n"
    }
  ],
  "summary": "Added modulo (%) operation to the calculator by implementing the modulo function in math.ts with proper error handling for modulo by zero, updating the calculator store to handle the % operation, adding the % button to the OperationButtons component, and including comprehensive tests for the modulo operation with edge cases including negative numbers, floating point numbers, and error conditions."
}